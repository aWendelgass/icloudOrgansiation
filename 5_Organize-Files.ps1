$DryRun = $false# ===================================================================# Verschiebt und benennt Dateien basierend auf der CSV-Steuerungsdatei## ** Damit das Skript ausgefuehrt werden kann muessen die Policies **# ** Fuer die Dauer des Prozesses geaendert werden, dazu habe ich  **# ** Die Batchdatei 4_doMerge-Data.bat erstellt, die kuemmert     **# ** sich darum und ruft das Script auf                          **## Das Skript gehoert zu einem Set of 5: Wenn alles ordnungsgemaess ablaeuft # koennt ihr damit eine beliebige Verzeichnisstruktur  von Bild und # Video Medien organisieren. Das heisst: Umbenennen, verschieben, # doppelte entfernen. #### !!!SICHERHEITSSCHALTER: DryRun oben in der ersten Zeile#    $true  = Nur Simulation (zeigt, was getan wuerde, KEINE Dateien werden veraendert)#    $false = Fuehrt die Operationen wirklich aus.## !! STARTEN SIE IMMER ZUERST MIT $true !!# --- Konfiguration ---$SkriptName = "Skript 5: Dateien organisieren"$CsvPath = Join-Path -Path $PSScriptRoot -ChildPath "4_Media-Export_extended.csv"# --- Lade Logging Modul ---try {    Import-Module -Name (Join-Path -Path $PSScriptRoot -ChildPath "MediaWorkflowLogger.psm1")} catch {    Write-Host "FEHLER: Das Logging-Modul 'MediaWorkflowLogger.psm1' konnte nicht geladen werden." -ForegroundColor Red    pause    return}# --- Lade UTF8 Helper Modul ---try {    Import-Module -Name (Join-Path -Path $PSScriptRoot -ChildPath "Utf8BomHelper.psm1")} catch {    Write-Host "FEHLER: Das UTF8 Helper Modul 'Utf8BomHelper.psm1' konnte nicht geladen werden." -ForegroundColor Red    pause    return}# Helper function to generate suffixes like a, b, ..., z, aa, ab, ...function Get-AlphabeticalSuffix {    param(        [int]$number # 0-based index for the suffix    )    $result = ""    $number++    while ($number -gt 0) {        $number--        $remainder = $number % 26        $result = [char]([int][char]'a' + $remainder) + $result        $number = [int]($number / 26)    }    return $result}Write-StructuredLog -LogLevel INFO -SkriptName $SkriptName -Message "Lese CSV-Steuerungsdatei ein: '$CsvPath'..."try {    try {        $data = Import-Csv -Path $CsvPath -Delimiter ';' -Encoding UTF8    } catch {        Write-StructuredLog -LogLevel WARN -SkriptName $SkriptName -Message "Einlesen mit Semikolon fehlgeschlagen, versuche Komma..."        $data = Import-Csv -Path $CsvPath -Delimiter ',' -Encoding UTF8    }} catch {    Write-StructuredLog -LogLevel ERROR -SkriptName $SkriptName -Message "FEHLER BEIM EINLESEN DER CSV-DATEI: $($_.Exception.Message)"    pause    return}Write-StructuredLog -LogLevel INFO -SkriptName $SkriptName -Message "Filtere Datensaetze: Es werden nur Zeilen mit Erledigt_Status = 1 beruecksichtigt."$workItems = $data | Where-Object { $_.Erledigt_Status -eq 1 }Write-StructuredLog -LogLevel INFO -SkriptName $SkriptName -Message "Beginne mit der Verarbeitung von $($workItems.Count) von $($data.Count) relevanten Datensaetzen..."if ($DryRun) { Write-StructuredLog -LogLevel WARN -SkriptName $SkriptName -Message "SKRIPT LAEUFT IM SIMULATIONSMODUS (-WhatIf)" }foreach ($row in $workItems) {    $sourceFile = ""    try {        $sourceFile = Join-Path -Path $row.Pfad -ChildPath $row.Dateiname        $destinationDirectory = $row.Neues_Verzeichnis        if (-not (Test-Path -LiteralPath $sourceFile)) {            Write-StructuredLog -LogLevel WARN -SkriptName $SkriptName -Message "Quelldatei nicht gefunden: $sourceFile" -FileObject $row; $row.Erledigt_Status = -1; continue        }        if (-not $destinationDirectory) {            Write-StructuredLog -LogLevel WARN -SkriptName $SkriptName -Message "Kein Zielverzeichnis fuer '$sourceFile' angegeben." -FileObject $row; $row.Erledigt_Status = -1; continue        }        if ([string]::IsNullOrWhiteSpace($row.Datumsstempel_fuer_Dateiname)) {            Write-StructuredLog -LogLevel WARN -SkriptName $SkriptName -Message "Kein Datumsstempel fuer '$sourceFile' gefunden. Datei wird uebersprungen." -FileObject $row; $row.Erledigt_Status = -1; continue        }        if (-not (Test-Path -Path $destinationDirectory)) {            if (-not $DryRun) {                New-Item -Path $destinationDirectory -ItemType Directory | Out-Null            } else {                Write-StructuredLog -LogLevel INFO -SkriptName $SkriptName -Message "[SIMULATION] Erstelle Verzeichnis '$destinationDirectory'"            }        }        $newBaseName = ""        $extension = $row.Extension        $datePart = $row.Datumsstempel_fuer_Dateiname        if ($row.Neuer_Name -and $row.Neuer_Name.Trim() -ne "") {            $newBaseName = $row.Neuer_Name.Trim() + "_" + $datePart        } else {            $newBaseName = $datePart        }        $finalFileName = $newBaseName + $extension        $destinationPath = Join-Path -Path $destinationDirectory -ChildPath $finalFileName        if (Test-Path -LiteralPath $destinationPath) {            $sourceFileInfo = Get-Item -LiteralPath $sourceFile            $destFileInfo = Get-Item -LiteralPath $destinationPath            if ($sourceFileInfo.Length -eq $destFileInfo.Length) {                Write-StructuredLog -LogLevel WARN -SkriptName $SkriptName -Message "DUPLIKAT GEFUNDEN: '$($sourceFile)' ist identisch mit einer Datei im Ziel (Name und Groesse). Status wird auf 3 gesetzt." -FileObject $row                $row.Erledigt_Status = 3                continue            } else {                $counter = 0                do {                    $suffix = Get-AlphabeticalSuffix -number $counter                    $finalFileName = "${newBaseName}_${suffix}${extension}"                    $destinationPath = Join-Path -Path $destinationDirectory -ChildPath $finalFileName                    $counter++                } while (Test-Path -LiteralPath $destinationPath)            }        }        $row.Neuer_Name = $finalFileName.Replace($extension, '')        if ($DryRun) {            Write-StructuredLog -LogLevel INFO -SkriptName $SkriptName -Message "[SIMULATION] Verschiebe '$sourceFile' nach '$destinationPath'"        } else {            [System.IO.File]::Move($sourceFile, $destinationPath)        }        $row.Erledigt_Status = 2    } catch {        Write-StructuredLog -LogLevel ERROR -SkriptName $SkriptName -Message "FEHLER bei der Verarbeitung von '$sourceFile': $($_.Exception.Message)" -FileObject $row        $row.Erledigt_Status = -1    }}if (-not $DryRun) {    $tempCsvPath = Join-Path -Path $PSScriptRoot -ChildPath "4_Media-Export_extended_temp.csv"    Write-StructuredLog -LogLevel INFO -SkriptName $SkriptName -Message "Speichere aktualisierte CSV-Datei..."    try {        #  alt  $data | Export-Csv -Path $tempCsvPath -NoTypeInformation -Delimiter ';' -Encoding UTF8BOM        Export-CsvWithBom -Data $data -Path $tempCsvPath -Delimiter ';'        Move-Item -Path $tempCsvPath -Destination $CsvPath -Force        Write-StructuredLog -LogLevel INFO -SkriptName $SkriptName -Message "FERTIG! Alle markierten Dateien wurden verarbeitet und die CSV-Datei wurde aktualisiert."    } catch {        Write-StructuredLog -LogLevel ERROR -SkriptName $SkriptName -Message "FEHLER BEIM SPEICHERN DER CSV-DATEI: $($_.Exception.Message)"        pause    }} else {    Write-StructuredLog -LogLevel INFO -SkriptName $SkriptName -Message "Simulation abgeschlossen. Ueberpruefen Sie die Ausgabe oben."}pause