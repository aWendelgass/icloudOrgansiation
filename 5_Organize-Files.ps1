$DryRun = $false# ===================================================================# Verschiebt und benennt Dateien basierend auf der CSV-Steuerungsdatei## ** Damit das Skript ausgefuehrt werden kann muessen die Policies **# ** Fuer die Dauer des Prozesses geaendert werden, dazu habe ich  **# ** Die Batchdatei 4_doMerge-Data.bat erstellt, die kuemmert     **# ** sich darum und ruft das Script auf                          **## Das Skript gehoert zu einem Set of 5: Wenn alles ordnungsgemaess ablaeuft # koennt ihr damit eine beliebige Verzeichnisstruktur  von Bild und # Video Medien organisieren. Das heisst: Umbenennen, verschieben, # doppelte entfernen. #### !!!SICHERHEITSSCHALTER: DryRun oben in der ersten Zeile#    $true  = Nur Simulation (zeigt, was getan wuerde, KEINE Dateien werden veraendert)#    $false = Fuehrt die Operationen wirklich aus.## !! STARTEN SIE IMMER ZUERST MIT $true !!# Helper function to generate suffixes like a, b, ..., z, aa, ab, ...function Get-AlphabeticalSuffix {    param(        [int]$number # 0-based index for the suffix    )    $result = ""    $number++    while ($number -gt 0) {        $number--        $remainder = $number % 26        $result = [char]([int][char]'a' + $remainder) + $result        $number = [int]($number / 26)    }    return $result}$CsvPath = Join-Path -Path $PSScriptRoot -ChildPath "4_Media-Export_extended.csv"Write-Host "Lese CSV-Steuerungsdatei ein: '$CsvPath'..." -ForegroundColor Greentry {    # Use Import-Csv for significantly faster loading.    # German Excel often uses semicolons as separators in CSV files.    # We will try semicolon first, then comma.    try {        $data = Import-Csv -Path $CsvPath -Delimiter ';'    } catch {        Write-Host "Einlesen mit Semikolon fehlgeschlagen, versuche Komma..." -ForegroundColor Yellow        $data = Import-Csv -Path $CsvPath -Delimiter ','    }} catch {    Write-Host "FEHLER BEIM EINLESEN DER CSV-DATEI:" -ForegroundColor Red; Write-Host $_.Exception.Message -ForegroundColor Red; pause; return}# Filter data to get only rows that need processing.Write-Host "Filtere Datensaetze: Es werden nur Zeilen mit Erledigt_Status = 1 beruecksichtigt." -ForegroundColor Green$workItems = $data | Where-Object { $PSItem.Erledigt_Status -eq 1 }Write-Host "Beginne mit der Verarbeitung von $($workItems.Count) von $($data.Count) relevanten Datensaetzen..."if ($DryRun) { Write-Host "--- SKRIPT LAeUFT IM SIMULATIONSMODUS (-WhatIf) ---" -ForegroundColor Yellow }# Loop only over the filtered dataforeach ($row in $workItems) {    $sourceFile = ""    try {        $sourceFile = Join-Path -Path $row.Pfad -ChildPath $row.Dateiname        $destinationDirectory = $row.Neues_Verzeichnis        if (-not (Test-Path -LiteralPath $sourceFile)) {            Write-Warning "Quelldatei nicht gefunden: $sourceFile"; $row.Erledigt_Status = -1; continue        }        if (-not $destinationDirectory) {            Write-Warning "Kein Zielverzeichnis fuer '$sourceFile' angegeben."; $row.Erledigt_Status = -1; continue        }        if ([string]::IsNullOrWhiteSpace($row.Datumsstempel_fuer_Dateiname)) {            Write-Warning "Kein Datumsstempel fuer '$sourceFile' gefunden. Datei wird uebersprungen."; $row.Erledigt_Status = -1; continue        }        if (-not (Test-Path -Path $destinationDirectory)) {            if (-not $DryRun) {                New-Item -Path $destinationDirectory -ItemType Directory | Out-Null            } else {                Write-Host "[SIMULATION] Erstelle Verzeichnis '$destinationDirectory'"            }        }        $newBaseName = ""        $extension = $row.Extension        $datePart = $row.Datumsstempel_fuer_Dateiname # Directly use the pre-formatted string        if ($row.Neuer_Name -and $row.Neuer_Name.Trim() -ne "") {            $newBaseName = $row.Neuer_Name.Trim() + "_" + $datePart        } else {            $newBaseName = $datePart        }        $finalFileName = $newBaseName + $extension        $destinationPath = Join-Path -Path $destinationDirectory -ChildPath $finalFileName        # Check for duplicates or name collisions        if (Test-Path -LiteralPath $destinationPath) {            # A file with the same name exists. Check if it's a true duplicate by comparing size.            $sourceFileInfo = Get-Item -LiteralPath $sourceFile            $destFileInfo = Get-Item -LiteralPath $destinationPath            if ($sourceFileInfo.Length -eq $destFileInfo.Length) {                # IDENTICAL FILE: Same name and size. Mark as duplicate and skip.                Write-Warning "DUPLIKAT GEFUNDEN: '$($sourceFile)' ist identisch mit einer Datei im Ziel (Name und Groesse). Status wird auf 3 gesetzt."                $row.Erledigt_Status = 3                continue # Exit this iteration of the foreach loop            } else {                # NAME COLLISION: Same name but different size. Find a new name with a suffix.                $counter = 0                do {                    $suffix = Get-AlphabeticalSuffix -number $counter                    $finalFileName = "${newBaseName}_${suffix}${extension}"                    $destinationPath = Join-Path -Path $destinationDirectory -ChildPath $finalFileName                    $counter++                } while (Test-Path -LiteralPath $destinationPath)            }        }        # At this point, $destinationPath is guaranteed to be a unique path.        $row.Neuer_Name = $finalFileName.Replace($extension, '')        if ($DryRun) {            Write-Host "[SIMULATION] Verschiebe '$sourceFile' nach '$destinationPath'"        } else {            [System.IO.File]::Move($sourceFile, $destinationPath)        }        $row.Erledigt_Status = 2    } catch {        Write-Warning "FEHLER bei der Verarbeitung von '$sourceFile': $($_.Exception.Message)"        $row.Erledigt_Status = -1    }}# The changes have been applied to the $data object by reference.# Now, save the entire $data object back to the file.if (-not $DryRun) {    $tempCsvPath = Join-Path -Path $PSScriptRoot -ChildPath "4_Media-Export_extended_temp.csv"    Write-Host "Speichere aktualisierte CSV-Datei..." -ForegroundColor Green    try {        # Export the complete but updated $data object to a new CSV        $data | Export-Csv -Path $tempCsvPath -NoTypeInformation -Delimiter ';'                # Replace the original file with the temporary file        Move-Item -Path $tempCsvPath -Destination $CsvPath -Force                Write-Host "FERTIG! Alle markierten Dateien wurden verarbeitet und die CSV-Datei wurde aktualisiert." -ForegroundColor Cyan    } catch {        Write-Host "FEHLER BEIM SPEICHERN DER CSV-DATEI:" -ForegroundColor Red        Write-Host $_.Exception.Message -ForegroundColor Red        # Pause to allow user to see the error message before the console closes        pause    }} else {    Write-Host "Simulation abgeschlossen. Ueberpruefen Sie die Ausgabe oben." -ForegroundColor Yellow}pause