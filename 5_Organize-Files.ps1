$DryRun = $false# ===================================================================# Verschiebt und benennt Dateien basierend auf der CSV-Steuerungsdatei## ** Damit das Skript ausgeführt werden kann müssen die Policies **# ** Für die Dauer des Prozesses geändert werden, dazu habe ich  **# ** Die Batchdatei 4_doMerge-Data.bat etstellt, die kümmert     **# ** sich darum und ruft das Script auf                          **## Das Skript gehört zu einem Set of 5: Wenn alles ordnungsgemäß abläuft # könnt ihr damit eine beliebiege Verzeichnissttruktur  von Bild und # Video Medien organsieren. Das heisst: Umbenennen, verschieben, # doppelte entfernen. #### !!!SICHERHEITSSCHALTER: DryRun oben in der ersten Zeile#    $true  = Nur Simulation (zeigt, was getan würde, KEINE Dateien werden verändert)#    $false = Führt die Operationen wirklich aus.## !! STARTEN SIE IMMER ZUERST MIT $true !!$ExcelPath = Join-Path -Path $PSScriptRoot -ChildPath "4_Media-Export_extended.xlsx"Import-Module ImportExcelWrite-Host "Lese Excel-Steuerungsdatei ein: '$ExcelPath'..." -ForegroundColor Greentry {    $data = Import-Excel -Path $ExcelPath} catch {    Write-Host "FEHLER BEIM EINLESEN DER EXCEL-DATEI:" -ForegroundColor Red; Write-Host $_.Exception.Message -ForegroundColor Red; pause; return}Write-Host "Beginne mit der Verarbeitung von $($data.Count) Datensätzen..."if ($DryRun) { Write-Host "--- SKRIPT LÄUFT IM SIMULATIONSMODUS (-WhatIf) ---" -ForegroundColor Yellow }# Wir erstellen eine komplett neue Ergebnisliste, anstatt die alte zu modifizieren$newData = [System.Collections.Generic.List[PSObject]]::new()foreach ($row in $data) {    # Verarbeite nur Zeilen, die mit 1 markiert sind    if ($row.Erledigt_Status -eq 1) {        $sourceFile = ""        try {            $sourceFile = Join-Path -Path $row.Pfad -ChildPath $row.Dateiname            $destinationDirectory = $row.Neues_Verzeichnis            if (-not (Test-Path -LiteralPath $sourceFile)) {                Write-Warning "Quelldatei nicht gefunden: $sourceFile"; $row.Erledigt_Status = -1; continue            }            if (-not $destinationDirectory) {                Write-Warning "Kein Zielverzeichnis für '$sourceFile' angegeben."; $row.Erledigt_Status = -1; continue            }            if ([string]::IsNullOrWhiteSpace($row.Erstelldatum_Zeit_des_Mediums)) {                Write-Warning "Kein Erstelldatum für '$sourceFile' gefunden. Datei wird übersprungen."; $row.Erledigt_Status = -1; continue            }            if (-not (Test-Path -Path $destinationDirectory)) {                New-Item -Path $destinationDirectory -ItemType Directory -WhatIf:$DryRun | Out-Null            }            $newBaseName = ""            $extension = $row.Extension            if ($row.Erstelldatum_Zeit_des_Mediums -is [double]) {                $dateObject = [datetime]::FromOADate($row.Erstelldatum_Zeit_des_Mediums)            } else {                $dateObject = [datetime]$row.Erstelldatum_Zeit_des_Mediums            }            $datePart = $dateObject.ToString("yyyyMMdd_HHmmss")            if ($row.Neuer_Name -and $row.Neuer_Name.Trim() -ne "") {                $newBaseName = $row.Neuer_Name.Trim() + "_" + $datePart            } else {                $newBaseName = $datePart            }            $finalFileName = $newBaseName + $extension            $destinationPath = Join-Path -Path $destinationDirectory -ChildPath $finalFileName            $counter = 0            while (Test-Path -LiteralPath $destinationPath) {                $counter++; $suffix = [char](96 + $counter)                $finalFileName = "${newBaseName}_${suffix}${extension}"                $destinationPath = Join-Path -Path $destinationDirectory -ChildPath $finalFileName            }            $row.Neuer_Name = $finalFileName.Replace($extension, '')            Move-Item -LiteralPath $sourceFile -Destination $destinationPath -WhatIf:$DryRun            $row.Erledigt_Status = 2        } catch {            Write-Warning "FEHLER bei der Verarbeitung von '$sourceFile': $($_.Exception.Message)"            $row.Erledigt_Status = -1        }    }    # Füge JEDE Zeile (ob verändert oder nicht) zur neuen Datenliste hinzu    $newData.Add($row)}if (-not $DryRun) {    Write-Host "Speichere aktualisierte Excel-Datei..." -ForegroundColor Green    $newData | Export-Excel -Path $ExcelPath -AutoSize -ClearSheet -TableStyle None    Write-Host "FERTIG! Alle markierten Dateien wurden verarbeitet." -ForegroundColor Cyan} else {    Write-Host "Simulation abgeschlossen. Überprüfen Sie die Ausgabe oben." -ForegroundColor Yellow}pause